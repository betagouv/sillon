# Simple ? Explications

_Les principaux enjeux ont dÃ©jÃ  Ã©tÃ© mentionnÃ©s dans les prÃ©cÃ©dents chapitres (dont celui sur [la portabilitÃ© d'un produit](database-for-everything/maintenance.mdx))._

Nous prÃ©conisons de choisir chez un hÃ©bergeur ce qui pourrait se rÃ©fÃ©rer au â€œ[serverless](https://en.wikipedia.org/wiki/Serverless_computing)â€ pour votre applicatif, ce afin de juste avoir Ã  jouer sur le nombre d'instances ou les ressources disponibles pour rÃ©pondre Ã  votre besoin. Nous parlons ici de serverless sur des â€œimages finalesâ€ dont la technologie est open source (comme Docker ou Buildpack), et non pas de [FaaS](https://en.wikipedia.org/wiki/Function_as_a_service) (functions as a service).

_Les FaaS rÃ©pondent Ã  un besoin sommaire (comme un script), mais rarement au besoin d'un produit complet (sachant qu'un ensemble de â€œfunctionsâ€ indÃ©pendantes poserait un problÃ¨me de synchronisation des versions du runtime comme mentionnÃ© [ici](frontend-backend-close/monorepository.mdx))._

Il nous semble par exemple dÃ©mesurÃ© de gÃ©rer la complexitÃ© de ressources sur un cluster Kubernetes pour gÃ©rer un produit. Bien Ã©videmment certaines entitÃ©s ont dÃ©jÃ  de tels clusters en place et on vous redirige vers [la validitÃ© de ce guide](preamble/validity.mdx) pour ne pas Ãªtre en porte-Ã -faux vis-Ã -vis de votre entitÃ©. Gardez juste en tÃªte que le coÃ»t opÃ©rationnel (temps / argent) pour maintenir de tels outils est bien supÃ©rieur au fait de payer un hÃ©bergeur tiers. D'ailleurs ceux qui sont dÃ©jÃ  passÃ©s par-lÃ  ont peut-Ãªtre remarquÃ© que finalement on refait le travail d'un hÃ©bergeur traditionnel, sauf que l'on a pas le budget pour (ni la lÃ©gitimitÃ© pour ğŸ˜Š), et on arrive difficilement Ã  un rÃ©sultat qualitatif (autonomie des Ã©quipes, documentation, outils de monitoringâ€¦).
