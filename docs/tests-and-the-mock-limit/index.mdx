# Les tests et la limite du mock

Nous ne sommes pas pour imposer des tests Ã  tous les niveaux et sur tout votre code applicatif. Il est beaucoup plus important selon nous de :

- DÃ©montrer que votre produit sert rÃ©ellement en rÃ©pondant aux besoins utilisateurs (et donc en dÃ©veloppant des fonctionnalitÃ©s) ;
- D'avoir un maximum de flexibilitÃ© dans la maintenance de votre outil, car mÃªme en testant, il vous arrivera des pÃ©pins auxquels vous n'auriez jamais pensÃ©s.

Essayez de focaliser vos tests unitaires sur des briques critiques qui gÃ¨rent de la donnÃ©e mÃ©tier (validation d'un numÃ©ro de tÃ©lÃ©phone, gÃ©nÃ©ration d'une URL signÃ©e pour un fichierâ€¦). AprÃ¨s si vous Ãªtes Ã  l'aise et efficace avec le [TDD](https://fr.wikipedia.org/wiki/Test_driven_development) ou le [BDD](https://en.wikipedia.org/wiki/Behavior-driven_development), bien entendu il faut continuer les pratiques qui marchent ğŸ˜‰.

_De toute faÃ§on avec le temps votre pourcentage de couverture en tests va progresser, il est probable qu'Ã  chaque bug remontÃ© il soit plus facile de le tester de maniÃ¨re isolÃ©e de l'applicatif (impliquant de faire des tests unitaires pour facilement dÃ©bugger)._

Par contre, quand on veut tester Ã  un niveau plus abstrait on se retrouve souvent Ã  faire des mocks qui ne veulent plus rien dire puisqu'on les a fait spÃ©cifiquement pour que le test concernÃ© passe. Par exemple, si l'on veut tester un code qui a des interactions avec la base de donnÃ©es, on peut essayer de mocker la base, mais Ã§a ne nous dira jamais si finalement la requÃªte de jointure ou les `SELECT` imbriquÃ©s auraient marchÃ© dans une vraie situation. Il existe pourtant bien quelques librairies qui essaient de faire â€œdatabase in memoryâ€ mais Ã§a ne reste qu'une pseudo-copie oÃ¹ vous n'aurez pas les vraies problÃ©matiques de l'outil.

Si vous souhaitez faire des tests d'intÃ©gration, nous prÃ©conisons de faire des tests en restant local Ã  votre code, avec toute la logique dans votre test (comme pour des tests unitaires). Pour cela nous utilisons [`test-containers`](https://github.com/testcontainers/testcontainers-node) qui va communiquer avec votre Docker local pour peupler de faÃ§on Ã©phÃ©mÃ¨re par exemple une PostgreSQL, un [`mailcatcher`](https://hub.docker.com/r/aerzas/mailcatcher)â€¦ afin de faire des tests qui reproduisent un minimum l'environnement de production. Comme l'image d'un container est en cache aprÃ¨s le premier test, peupler un container prend Ã  peine quelques secondes et cela devient totalement transparent.

_Le processus marche aussi dans les CI/CD (en tout cas sur GitHub Actions) puisque le runner Docker est disponible via son API HTTP, donc vos tests sont en mesure de dire Ã  la pipeline â€œpeuple un container, puis Ã©teins-leâ€. Plus besoin de spÃ©cifier en dur dans la pipeline les potentielles dÃ©pendances de services_ ğŸ™Œ*.*
